import requests
import pandas as pd
from pathlib import Path
import sys

# --- CONFIGURATION & RECHERCHE ---

def find_requirements_files(start_dir="."):
    """Parcourt r√©cursivement pour trouver les fichiers requirements.txt."""
    base_path = Path(start_dir)
    requirements_paths = list(base_path.rglob("requirements.txt"))
    return requirements_paths

def get_file_content(file_path):
    """Lit le contenu d'un fichier."""
    try:
        return file_path.read_text()
    except Exception as e:
        print(f"‚ùå Erreur lors de la lecture de {file_path}: {e}")
        return ""

# --- PARSING ---

def parse_requirements(requirements_content):
    """Parse le contenu et retourne une liste de tuples (package, version, contrainte)."""
    dependencies = []
    for line in requirements_content.splitlines():
        line = line.strip()
        if not line or line.startswith(("#", "-r", "git+")):
            continue
        
        if "==" in line:
            pkg, ver = line.split("==")
            dependencies.append((pkg.strip(), ver.strip(), "fixed"))
        elif ">=" in line:
            pkg, ver = line.split(">=")
            dependencies.append((pkg.strip(), ver.strip(), "minimum"))
        elif "~=" in line:
            pkg, ver = line.split("~=")
            dependencies.append((pkg.strip(), ver.strip(), "compatible"))
        else:
            dependencies.append((line.strip(), "", "latest"))
    return dependencies

# --- ANALYSE DE VULN√âRABILIT√â (API OSV) ---

def fetch_vulnerabilities_details(vulnerabilities):
    """Transforme les donn√©es brutes de l'API en DataFrame exploitable."""
    details = []
    for vuln in vulnerabilities:
        details.append({
            "id": vuln.get("id"),
            "summary": vuln.get("summary", "No summary available"),
            "severity": vuln.get("database_specific", {}).get("severity", "UNKNOWN"),
            "affected_versions": vuln.get("affected", [{}])[0].get("versions", [])
        })
    return pd.DataFrame(details)

def filter_based_on_constraints(vulnerabilities_df, version, constraint):
    """Applique ta logique de filtrage selon le type de contrainte pip."""
    if vulnerabilities_df.empty:
        return vulnerabilities_df
        
    if constraint == "minimum":
        return vulnerabilities_df[vulnerabilities_df["affected_versions"].apply(lambda vs: any(v >= version for v in vs))]
    elif constraint == "compatible":
        prefix = ".".join(version.split(".")[:-1])
        return vulnerabilities_df[vulnerabilities_df["affected_versions"].apply(lambda vs: any(v.startswith(prefix) for v in vs))]
    elif constraint == "fixed":
        return vulnerabilities_df[vulnerabilities_df["affected_versions"].apply(lambda vs: version in vs)]
    
    return vulnerabilities_df

def check_vulnerability(package_name, version, constraint):
    """Interroge l'API et filtre les r√©sultats."""
    url = "https://api.osv.dev/v1/query"
    payload = {"package": {"name": package_name, "ecosystem": "PyPI"}}
    if version:
        payload["version"] = version

    response = requests.post(url, json=payload)
    if response.status_code == 200:
        data = response.json()
        vulns = data.get("vulns", [])
        if not vulns:
            return pd.DataFrame()
        
        df = fetch_vulnerabilities_details(vulns)
        df["package"] = package_name
        df["input_version"] = version
        return filter_based_on_constraints(df, version, constraint)
    return pd.DataFrame()

# --- R√âSUM√â ET SORTIE ---

def run_scanner(start_dir="."):
    """Fonction principale qui orchestre le scan."""
    files = find_requirements_files(start_dir)
    if not files:
        print("üîç Aucun fichier requirements.txt trouv√©.")
        return

    all_vulnerabilities = []

    for file_path in files:
        print(f"--- Analyse de : {file_path} ---")
        content = get_file_content(file_path)
        deps = parse_requirements(content)
        
        for package, version, constraint in deps:
            res = check_vulnerability(package, version, constraint)
            if not res.empty:
                all_vulnerabilities.append(res)
    if not all_vulnerabilities:
        print("\n‚úÖ Aucune vuln√©rabilit√© d√©tect√©e.")
        sys.exit(0)
    else:
        vulnerabilities_df = pd.concat(all_vulnerabilities, ignore_index=True)
        print(f"‚ö†Ô∏è {len(vulnerabilities_df)} vuln√©rabilit√©(s) trouv√©e(s) :")
        # Affichage du nombre de vuln√©rabilit√©s par s√©v√©rit√©
        severity_counts = vulnerabilities_df["severity"].value_counts()
        for severity, count in severity_counts.items():
            print(f"  - {severity}: {count} vuln√©rabilit√©(s)")
        # Affichage des packages li√©s aux s√©v√©rit√©s High et Critical
        for severity in ["HIGH", "CRITICAL"]:
            if severity in severity_counts:
                print(f"\nüìå Packages avec des vuln√©rabilit√©s {severity} :")
                for package in vulnerabilities_df[vulnerabilities_df["severity"] == severity]["package"].unique():
                    print(f"  - {package}")
        
        # Exit Code 1 si des vuln√©rabilit√©s critiques ou hautes sont pr√©sentes
        critical_count = len(vulnerabilities_df[vulnerabilities_df["severity"].isin(["HIGH", "CRITICAL"])])
        if critical_count > 0:
            print(f"\n‚ùå Scan √©chou√© : {critical_count} vuln√©rabilit√©s critiques/hautes trouv√©es.")
            sys.exit(1)

if __name__ == "__main__":
    run_scanner()